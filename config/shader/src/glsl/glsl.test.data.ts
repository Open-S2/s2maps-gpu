// Testing shaders
export const GLSLModules = {
  "getQuadVertex": "#pragma import {SolidVertex} from 'use/types'\n#pragma import {viewUniforms, worldToClip, getPerspectiveScale} from 'use/view'\n#pragma import {getQuadUV} from 'geometry/quad'\n\nvec4 getPosition(int);\nvec4 getColor(int);\nvec2 getSize(int);\nfloat getDepth(int);\n\n#pragma export\nSolidVertex getQuadVertex(int vertexIndex, int instanceIndex) {\n  vec4 position = getPosition(instanceIndex);\n  vec4 color = getColor(instanceIndex);\n  vec2 size = getSize(instanceIndex);\n  float depth = getDepth(instanceIndex);\n\n  vec4 center = worldToClip(position);\n\n  vec2 uv = getQuadUV(vertexIndex);\n  vec2 xy = uv * 2.0 - 1.0;\n  \n  // Lerp between fixed size and full perspective.\n  float pixelScale = getPerspectiveScale(center.w, depth);\n  size *= pixelScale;\n\n  #ifdef HAS_EDGE_BLEED\n  xy = xy * (size + 0.5) / size;\n  uv = xy * .5 + .5;\n  #endif\n\n  center.xy += xy * size * viewUniforms.viewResolution * center.w;\n\n  return SolidVertex(\n    center,\n    color,\n    uv\n  );\n}",

  "instance/fragment/solid": "#pragma import {getPickingColor} from 'use/picking';\n\nvec4 getFragment(vec4, vec2);\n\n#ifdef IS_PICKING\nlayout(location = 0) in flat uint fragIndex;\nlayout(location = 0) out uvec4 outColor;\n#else\nlayout(location = 0) in vec4 fragColor;\nlayout(location = 1) in vec2 fragUV;\n\nlayout(location = 0) out vec4 outColor;\n#endif\n\n#ifdef IS_PICKING\nvoid main() {\n  outColor = getPickingColor(fragIndex);\n}\n#else\nvoid main() {\n  outColor = fragColor;\n  outColor.xyz *= outColor.a;\n\n  outColor = getFragment(outColor, fragUV);\n\n  if (outColor.a <= 0.0) discard;\n}\n#endif\n",

  "use/view": "#pragma export\nlayout(set = VIEW_BINDGROUP, binding = VIEW_BINDING) uniform ViewUniforms {\n  mat4 projectionMatrix;\n  mat4 viewMatrix;\n  vec4 viewPosition;\n  vec2 viewResolution;\n  vec2 viewSize;\n  float viewWorldDepth;\n  float viewPixelRatio;\n} viewUniforms;\n\n#pragma export\nvec4 worldToView(vec4 position) {\n  return viewUniforms.viewMatrix * position;\n}\n\n#pragma export\nvec4 viewToClip(vec4 position) {\n  return viewUniforms.projectionMatrix * position;\n}\n\n#pragma export\nvec4 worldToClip(vec4 position) {\n  return viewToClip(worldToView(position));\n}\n\n#pragma export\nvec3 clipToScreen3D(vec4 position) {\n  return vec3(position.xy * viewUniforms.viewSize, position.z);\n}\n\n#pragma export\nvec3 screenToClip3D(vec4 position) {\n  return vec3(position.xy * viewUniforms.viewResolution, position.z);\n}\n\n#pragma export\nvec3 worldToClip3D(vec4 position) {\n  position = viewToClip(worldToView(position));\n  return position.xyz / position.w;\n}\n\n#pragma export\nfloat getPerspectiveScale(float w, float f) {\n  mat4 m = viewUniforms.projectionMatrix;\n  float worldScale = m[1][1] * viewUniforms.viewWorldDepth;\n  float clipScale = mix(1.0, worldScale / w, f);\n  float pixelScale = clipScale * viewUniforms.viewPixelRatio;\n  return pixelScale;\n}\n",

  "use/types": "#pragma export\nstruct SolidVertex {\n  vec4 position;\n  vec4 color;\n  vec2 uv;\n};\n\n#pragma export\nstruct MeshVertex {\n  vec4 position;\n  vec3 normal;\n  vec4 color;\n  vec2 uv;\n};",

  "geometry/quad": "const ivec2 QUAD[] = {\n  ivec2(0, 0),\n  ivec2(1, 0),\n  ivec2(0, 1),\n  ivec2(1, 1),\n};\n\n#pragma export\nivec2 getQuadIndex(int vertex) {\n  return QUAD[vertex];\n}\n\n#pragma export\nvec2 getQuadUV(int vertex) {\n  return vec2(getQuadIndex(vertex));\n}\n",
};
export default GLSLModules;
